# Cursor Rules — AI Governance Framework

> These rules are specific to **Cursor**. Shared governance rules live in
> `ai-governance/GOVERNANCE-RULES.md` — read that file for the full auto-router,
> hard rules, and self-alignment instructions.

## MANDATORY: Load Governance

On your **first response in any conversation**, read these files to load governance rules:
1. `ai-governance/GOVERNANCE-RULES.md` — auto-router, hard rules, self-alignment

Then follow the auto-router on every subsequent prompt.

## How Cursor Executes Governance

Cursor does **not** have a workflow file system. Instead, governance is enforced through rules files and inline guidance.

When the auto-router (from GOVERNANCE-RULES.md) detects an intent:

1. **Announce** the detected workflow (format in GOVERNANCE-RULES.md)
2. **Read the relevant policies** from `ai-governance/policies/` for the detected intent
3. **Follow the task routing steps** defined in GOVERNANCE-RULES.md (Task Routing — Policy Chains)
4. Use Cursor's tools to implement changes and verify

### Intent → Policy Files to Read

| Intent | Read These Policies |
|--------|-------------------|
| Incident | `ai-governance/policies/POL-010-incident-response.md`, `POL-008-observability.md` |
| Security Review | `POL-006-security-privacy.md`, `POL-013-data-classification.md`, `POL-017-secrets-management.md` |
| Bug Fix | `POL-004-coding-standards.md`, `POL-005-testing.md` |
| Deploy | `POL-007-deployment.md`, `POL-012-change-management.md` |
| New Project | `POL-001-requirements.md`, `POL-002-architecture.md`, `POL-004-coding-standards.md` |
| Add Feature | `POL-001-requirements.md`, `POL-003-design.md`, `POL-005-testing.md`, `POL-004-coding-standards.md`, `POL-006-security-privacy.md` |
| Refactor | `POL-004-coding-standards.md`, `POL-005-testing.md` |
| Code Review | All applicable |

## Cursor-Specific Capabilities

### Composer Mode (Multi-File Editing)
- Composer is Cursor's agentic mode — use it for multi-file changes
- Can create, edit, and delete files across the project
- Can run terminal commands for verification (linting, testing)
- Best for: feature implementation, refactoring, bug fixes

### Chat Mode (Conversation)
- For discussion, code review, architecture decisions, debugging
- Use `@file` to reference specific files in conversation
- Use `@folder` to reference a directory
- Use `@codebase` for broad codebase questions
- Best for: code review, security review, incident triage, design discussions

### Inline Editing (Cmd+K)
- For quick, focused single-location edits
- Best for: small bug fixes, renaming, quick refactors

### Terminal Integration
- Run commands via Composer for verification
- After code changes: run linter/formatter
- After implementation: run the project's test suite

## Persistence (Self-Learn)

Cursor persists preferences via `.cursor/rules/` files:
- When you learn a user preference (code style, testing approach, etc.), suggest creating a rule file
- Example: `.cursor/rules/user-preferences.md` for code style, frameworks, and patterns
- Always ask user permission before creating or modifying rule files
- Rules in `.cursor/rules/` are auto-loaded on every interaction

## When No Workflow Matches

- Still enforce the hard rules from `ai-governance/GOVERNANCE-RULES.md`
- Help the user normally — don't force a workflow
- If the work evolves into a recognizable intent, trigger mid-conversation

## Quick Reference

- **Shared rules:** `ai-governance/GOVERNANCE-RULES.md` (MUST read on first interaction)
- **Policies:** `ai-governance/policies/POL-001` through `POL-017`
- **Templates:** `ai-governance/templates/`
- **Router details:** `ai-governance/router/auto-router.md`
